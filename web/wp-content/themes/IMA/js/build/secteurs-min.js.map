{"version":3,"sources":["../../../../../../node_modules/smoothscroll-polyfill/dist/smoothscroll.js","../../../../../../src/js/components/secteurs.js"],"names":["polyfill","isMicrosoftBrowser","userAgent","userAgentPatterns","RegExp","join","test","scrollElement","x","y","this","scrollLeft","scrollTop","ease","k","Math","cos","PI","shouldBailOut","firstArg","undefined","behavior","TypeError","hasScrollableSpace","el","axis","clientHeight","ROUNDING_TOLERANCE","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","w","getComputedStyle","isScrollable","isScrollableY","isScrollableX","findScrollableParent","d","body","parentNode","host","step","context","time","value","currentX","currentY","elapsed","now","startTime","SCROLL_TIME","startX","startY","method","call","scrollable","requestAnimationFrame","bind","smoothScroll","scrollX","pageXOffset","scrollY","pageYOffset","original","scroll","window","document","documentElement","style","__forceSmoothScrollPolyfill__","Element","HTMLElement","scrollTo","scrollBy","elementScroll","prototype","scrollIntoView","performance","Date","navigator","left","top","SyntaxError","scrollableParent","parentRects","getBoundingClientRect","clientRects","position","module","exports","thumbnails","getElementsByClassName","length","smoothscroll","forEach","arr","callback","i","handleAnchors","event","thumbnail","hashtagIndex","href","indexOf","isAnchor","preventDefault","sectionName","slice","section","scrollDistance","handleLinks","addEventListener"],"mappings":"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","sourcesContent":["/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","import smoothscroll from 'smoothscroll-polyfill';\n\n(() => {\n    // Getting the thumbnails\n    const thumbnails = document.getElementsByClassName('js-thumbnail');\n\n    // Early return if there's no thumbnails\n    if (!thumbnails.length) return;\n        \n    // kick off the polyfill!\n    smoothscroll.polyfill();\n\n    const forEach = (arr, callback) => {\n        let i = 0;\n        const { length } = arr;\n        while (i < length) {\n            callback(arr[i], i);\n            i += 1;\n        }\n    };\n\n\n    const handleAnchors = (event, thumbnail) => {\n        const hashtagIndex = thumbnail.href.indexOf('#');\n        const isAnchor = hashtagIndex >= 0;\n        if (!isAnchor) return;\n        \n        // Prevent click if it's an anchor\n        event.preventDefault();\n        \n        // Get the section's name from the clicked anchor\n        const sectionName = thumbnail.href.slice(hashtagIndex + 1);\n        \n        // Getting section from anchor's name\n        const [section] = document.getElementsByClassName(sectionName);\n        if (!section) return;\n\n        const { top } = section.getBoundingClientRect();\n        const scrollDistance = (window.scrollY || window.pageYOffset) + top;\n\n        window.scroll({ top: scrollDistance, left: 0, behavior: 'smooth' });\n    };\n\n    const handleLinks = () => {\n        forEach(thumbnails, thumbnail => {\n            thumbnail.addEventListener('click', () => {\n                handleAnchors(event, thumbnail);\n            }, false)\n        })\n    };\n\n    handleLinks();\n})();"]}